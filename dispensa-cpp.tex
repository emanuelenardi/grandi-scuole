\documentclass[class=article, crop=false, 12pt]{standalone}

\usepackage{dispensa.preamble}

% NOTE metadati
\title{Appunti di {\Cpp}}
\author{Emanuele Nardi}
\date{\today}

% NOTE ciclo di compilazione con arara
% arara: pdflatex: { draft: yes, shell: yes }
% arara: pdflatex: { synctex: yes, shell: yes }
% arara: latexmk: { clean: partial }
% arara: clean: { extensions: [synctex.gz] }
\begin{document}
% NOTE stampa del titolo
\maketitle

% NOTE indice dei contenuti
\thispagestyle{empty}
\tableofcontents
\clearpage

\section{Ripasso del linguaggio C}

\subsection{Programma minimale}

Come ogni buon tutorial che si rispetti iniziamo costruendo ed analizzando il \emph{programma minimale} (ovvero quello più semplice possibile) del linguaggio C:

\inputminted{cpp}{assets/codes/cpp/ESEMPI_BASE/hello-world.cc}

Il codice stampa semplicemente la stringa  di testo \cpp{"Hello, World!"} sul terminale.
Iniziamo spiegandone le prime righe:
\begin{itemize}
	\item \cpp{#include <iostream>} importa la libreria standard che contiene tutte le funzioni principali. Nota che le librerie vengono importate all'inizio del file;
	\item la nuova libreria \texttt{iostream} richiede l'uso di uno spazio dei nomi per identificare univocamente le classi, qui ci viene in aiuto \cpp{using namespace std;} che indica al compilatore quale spazio dei nomi bisogna utilizzare (in questo caso quello della \texttt{standard library});
	\item \cpp{int} indica che il valore di ritorno della funzione è di tipo intero. In questo caso restituisce il valore \textsf{0} che --- per convenzione --- significa che la funzione è terminata correttamente;
	\item il \cpp{int main() {|\dots|}} è la funzione principale che viene eseguita dal compilatore come prima funzione. In questo caso non ha argomenti (indicato dalle parentesi tonde prive di parametri al loro interno).
	\item \cpp{cout} è una funzione speciale che ci permette di scrivere sul terminale (il quale viene definito lo \texttt{standard output}). Nota che se non avessimo impostato lo spazio dei nomi avremmo dovuto specificare \cpp{std::cout}.
\end{itemize}

\subsection{Comandi di base per Linux}

Abbiamo visto diversi comandi a lezione:

\begin{table}
	\begin{tabular}{@{} >{\ttfamily}l l l @{}}
		whoami & stampa l'utente attualemente loggato \\
		pwd & stampa la cartella corrente \\
		cd & permette di navigare fra le cartelle \\
		mkdir & permette di creare cartelle \\
		touch & permette di creare file \\
		mv & permette di spostare e rinominare file \\
		chmod & permette di modificare i permessi per un file \\
	\end{tabular}
\end{table}

\subsection{Eseguire il programma}

\noindent
Per eseguire il programma dobbiamo prima compilarlo con \texttt{g++}
\begin{minted}[linenos = false]{bash}
g++ hello-world.cc -o hello-world.out
\end{minted}
che crea un file oggetto chiamato \texttt{hello-world.out}, dopodiché lo eseguiamo
\begin{minted}[linenos = false]{bash}
./hello-world.out
\end{minted}
che stampa sullo schermo la scritta \cpp{"Hello, World!"}.

Notiamo che anche un programma molto semplice come questo può contenere al suo interno tanti piccoli dettagli: a prima vista possono sembrare sottigliezze ma, in un linguaggio complesso come il C, vanno ad accumularsi e, con il passare del tempo e della complessità dei programmi, rendono di difficile comprensione gli stessi.

In futuro non analizzeremo così nel dettaglio gli esercizi proposti ma solo la \emph{business logic}, ossia la logica di fondo di un determinato programma.

\subsection{Automatizzare il processo di esecuzione}

Apportando varie al modifiche al file ed avendo compilato numerose volte tendiamo a notare come il processo di compilazione e di esecuzione diventi noioso e ripetitvo.
La programmazione ci viene (anche stavolta) in aiuto.
Risolviamo un problema scrivendo un programma (in gergo informatico uno \emph{script}) che esegua un numero arbitrario di comandi.

\begin{minted}{bash}
#!/bin/bash               # indico il tipo di file
g++ hello-world.cc        # compilo
mv a.out hello-world.out  # rinomino
./hello-world.out         # eseguo
\end{minted}

\end{document}
